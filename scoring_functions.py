"""
Scoring Functions

Peter Turney, December 7, 2020
"""
import golly as g
import numpy as np
import random as rand
import csv
import math
import scoring_parameters as sparams
#
# cell_list_to_set(cell_list) -- return cell_set
#
def cell_list_to_set(cell_list):
  """
  Golly represents a cell list as [x1, y1, ..., xN, yN]. We
  convert this to a set of the form ((x1, y1), ..., (xN, yN)).
  Checking set membership is faster than checking list
  membership.
  """
  cell_set = set()
  for i in range(0, len(cell_list), 2):
    cell_set.add((cell_list[i], cell_list[i+1]))
  return cell_set
#
# semantic_vector(boundary_n0, cell_list_n0, boundary_n1, 
# cell_list_n1, num_samples) -- given the live cells at n0 steps 
# and n1 steps, return a semantic vector list
#
def semantic_vector(boundary_n0, cell_list_n0, \
                    boundary_n1, cell_list_n1, \
                    num_samples):
  """
  We have a list of live cells at time n0 and a list of live
  cells at time n1, both generated by g.getrect(). We generate
  a vector of the form 
     <b0, ..., b8, s0, ..., s8, u0, ..., u8, d0, ..., d8>
  where 
     - bi is the number of cells that are born from i neighbours
     - si is the number of cells that survive with i neighbours
     - ui is the number of cells that are unborn with i neighbours
     - di is the number of cells that die with i neighbours
  These counts are converted to probabilities by dividing them
  by num_samples.
  """
  # b = born, s = survive, u = unborn, d = die
  # intialize a semantic vector of zeroes of the form
  # <b0, b1, ..., b8, s0, s1, ..., s8, 
  #  u0, u1, ..., u8, d0, d1, ..., d8>
  sem_vec = [0.0] * sparams.single_vec_len
  # check for empty bounding boxes
  if (len(boundary_n0) == 0):
    return sem_vec
  if (len(boundary_n1) == 0):
    return sem_vec
  # convert lists to sets, for speed
  cell_set_n0 = cell_list_to_set(cell_list_n0)
  cell_set_n1 = cell_list_to_set(cell_list_n1)
  # find the widths and heights of the boundaries
  [x_n0, y_n0, width_n0, height_n0] = boundary_n0
  [x_n1, y_n1, width_n1, height_n1] = boundary_n1
  # make sure the n0 box is at least 3x3, because we can't sample 
  # from the edges of the n0 box
  if ((width_n0 < 3) or (height_n0 < 3)):
    return sem_vec
  # calculate the location of the edges of the n0 box
  left = x_n0
  right = x_n0 + width_n0 - 1
  top = y_n0
  bottom = y_n0 + height_n0 - 1
  # randomly generate num_samples (x, y) pairs within the limits
  # given by boundary_n0
  for i in range(0, num_samples):
    x = rand.randint(left + 1, right - 1)
    y = rand.randint(top + 1, bottom - 1)
    # take (x, y) to be the central cell in generation n0
    # - is (x, y) alive (1) or dead (0)?
    center_n0 = int((x, y) in cell_set_n0)
    # look at (x, y) in the next time step, generation n1
    # - is (x, y) alive (1) or dead (0)?
    center_n1 = int((x, y) in cell_set_n1)
    # count the number of living cells surrounding (x, y)
    # in generation n0 -- this will range from 0 to 8
    xm1 = x - 1
    xp1 = x + 1
    ym1 = y - 1
    yp1 = y + 1
    num_neighbours = int((x,   ym1) in cell_set_n0) \
                   + int((x,   yp1) in cell_set_n0) \
                   + int((xm1, ym1) in cell_set_n0) \
                   + int((xm1, y)   in cell_set_n0) \
                   + int((xm1, yp1) in cell_set_n0) \
                   + int((xp1, ym1) in cell_set_n0) \
                   + int((xp1, y)   in cell_set_n0) \
                   + int((xp1, yp1) in cell_set_n0)
    #
    # BORN (0 --> 1) = the complement of UNBORN
    # -----------------------------------------
    if (center_n0 == 0) and (center_n1 == 1):
      # births are in positions 0 to 8
      position = num_neighbours
      sem_vec[position] = sem_vec[position] + 1.0
    #
    # SURVIVE (1 --> 1) = the complement of DIE
    # -----------------------------------------
    elif (center_n0 == 1) and (center_n1 == 1):
      # survivals are in positions 9 to 17
      position = num_neighbours + 9
      sem_vec[position] = sem_vec[position] + 1.0
    #
    # UNBORN (0 --> 0) = the complement of BORN
    # -----------------------------------------
    elif (center_n0 == 0) and (center_n1 == 0):
      # unbirths are in positions 18 to 26
      position = num_neighbours + 18
      sem_vec[position] = sem_vec[position] + 1.0
    #
    # DIE (1 --> 0) = the complement of SURVIVE
    # -----------------------------------------
    elif (center_n0 == 1) and (center_n1 == 0):
      # deaths are in positions 27 to 35
      position = num_neighbours + 27
      sem_vec[position] = sem_vec[position] + 1.0
    # end of loop over num_samples
  # normalize sem_vec by num_samples
  for i in range(0, sparams.single_vec_len):
    sem_vec[i] = sem_vec[i] / float(num_samples)
  # make sure the vector sums to 1.0, since the elements are supposed
  # to be probabilities - but let's be tolerant of rounding errors
  test_sum = sum(sem_vec)
  assert 0.99 < test_sum
  assert 1.01 > test_sum  
  # check
  assert len(sem_vec) == sparams.single_vec_len
  # return the semantic vector - values should range within 0.0 to 1.0
  return sem_vec
#
# avg_sem_vec(sem_vec_list) -- returns the average of the semantic vector 
# over a number of trials
#
def avg_sem_vec(sem_vec_list):
  """
  Given a list of semantic vectors (a list of lists), return the
  average vector.
  """
  # intialize a vector of averages
  avg_sem_vec = [0.0] * sparams.single_vec_len
  # in case sem_vec_list is empty
  if (len(sem_vec_list) == 0):
    return avg_sem_vec
  # count the number of nonzero vectors in sem_vec_list
  num_nonzero_vecs = 0
  # iterate through the list
  for sem_vec in sem_vec_list:
    if (sum(sem_vec) > 0):
      num_nonzero_vecs = num_nonzero_vecs + 1
      # iterate through the elements of the vector
      for i in range(sparams.single_vec_len):
        avg_sem_vec[i] = avg_sem_vec[i] + sem_vec[i]
  # in case all vectors are zero vectors
  if (num_nonzero_vecs == 0):
    return avg_sem_vec
  # divide sum by number of vectors to get average
  for i in range(sparams.single_vec_len):
    avg_sem_vec[i] = avg_sem_vec[i] / float(num_nonzero_vecs)
  # make sure the vector sums to 1.0, since the elements are probabilities,
  # but let's be tolerant of rounding errors
  test_sum = sum(avg_sem_vec)
  assert 0.99 < test_sum
  assert 1.01 > test_sum
  # check
  assert len(avg_sem_vec) == sparams.single_vec_len
  # return result
  return avg_sem_vec
#
# complement(x) = 8 - x
#
def complement(x):
  """
  This is a helper function for reverse(rule) and unstrobe(rule).
  It is assumed that x is a character and the returned result
  is also a character.
  """
  return str(8 - int(x))
#
# reverse(rule) -- for any rule X, there is a black/white
# reversal, reverse(X), such that X in a black/white world
# behaves the same as reverse(X) in a white/black world
#
def reverse(rule):
  """
  Given a rule X, generate its black/white reversal.
  """
  #
  # https://www.conwaylife.com/wiki/Black/white_reversal
  #
  # "The black/white reversal of a pattern is the result of 
  # toggling the state of each cell in the universe: bringing 
  # dead cells to life, and killing live cells. The black/white 
  # reversal of a pattern is sometimes called an anti-pattern; 
  # for instance, the black/white reversal of a glider (in an 
  # appropriate rule) is referred to as an anti-glider. The 
  # black/white reversal of a rule is a transformation of a 
  # rule in such a way that the black/white reversal of any 
  # pattern (in the previous sense) will behave the same way 
  # under the new rule as the unreversed pattern did under the 
  # original rule."
  #
  # Note that some rules are their own reversals:
  #
  # https://www.conwaylife.com/wiki/OCA:Day_%26_Night
  #
  # See also:
  #
  # http://golly.sourceforge.net/Help/Algorithms/QuickLife.html#b0emulation
  #
  # a set of the allowed numbers of neighbours
  neighbours = set("012345678")
  # split rule at "/"
  [born, survive] = rule.split("/")
  # drop "B" and "S" and make sets
  born = set(born[1:])
  survive = set(survive[1:])
  # invert neighbour counts using set difference
  # - example: B0123478 --> B56, S01234678 --> S5
  born_inverse = neighbours - born
  survive_inverse = neighbours - survive
  # use S(8-x) for the B counts and B(8-x) for the S counts
  # - example: B56 --> S23, S5 --> B3
  born_complement    = map(complement, survive_inverse)
  survive_complement = map(complement, born_inverse)
  # sort and join
  born_final = "B" + "".join(sorted(born_complement))
  survive_final = "S" + "".join(sorted(survive_complement))
  # new rule
  reverse_rule = born_final + "/" + survive_final
  return reverse_rule
#
# unstrobe(rule) -- if a rule causes strobing, remove the 
# strobing effect
#
def unstrobe(rule):
  """
  Given a rule X that strobes, return a pair of rules,
  one for even generations and another for odd generations,
  such that there is no strobing.
  """
  #
  # https://www.conwaylife.com/wiki/Strobing_rule
  #
  # "A rule (i.e. a Life-like cellular automaton) is said to 
  # be strobing iff it contains B0 (dead cells get born if 
  # they have zero live neighbors) but not S8 (live cells do 
  # not survive if they have eight live neighbors). In strobing 
  # rules, the entire universe will "light up" (get born) and 
  # die again in successive alternate generations, creating a 
  # visual "strobing" effect."
  #
  # See also:
  #
  # http://golly.sourceforge.net/Help/Algorithms/QuickLife.html#b0emulation
  #
  # a set of the allowed numbers of neighbours
  neighbours = set("012345678")
  # split rule at "/"
  [born, survive] = rule.split("/")
  # drop "B" and "S" and make sets
  born = set(born[1:])
  survive = set(survive[1:])
  #
  # strobing if and only if B0 but not S8
  #
  if ("0" in born) and not ("8" in survive):
    # rule for even generations uses inverted neighbor counts
    # - example: B03/S23 --> B1245678/S0145678 (even)
    born_inverse = neighbours - born
    survive_inverse = neighbours - survive
    # sort and join
    born_final = "B" + "".join(sorted(born_inverse))
    survive_final = "S" + "".join(sorted(survive_inverse))
    # new even rule
    even_rule = born_final + "/" + survive_final
    # rule for odd generations uses S(8-x) for the B counts 
    # and B(8-x) for the S counts
    # - example: B03/S23 becomes B56/S58 (odd)
    born_complement    = map(complement, survive)
    survive_complement = map(complement, born)
    # sort and join
    born_final = "B" + "".join(sorted(born_complement))
    survive_final = "S" + "".join(sorted(survive_complement))
    # new odd rule
    odd_rule = born_final + "/" + survive_final
    #
    return [even_rule, odd_rule]
    #
  else:
    # no strobing -- this rule does not cause strobing,
    # so we return an empty list
    return []
    #
#
# unpack_B0(rule) -- returns one or two new rules that have
# the same behaviour, except there are no infinities and
# no strobing
#
def unpack_B0(rule):
  """
  Unpack B0 rules into their two parts. Each B0 rule
  can be decomposed into two parts, an odd rule and
  an even rule. These parts are necessary (1) to avoid
  infinities and (2) to avoid annoying strobe effects.
  """
  #
  # http://golly.sourceforge.net/Help/Algorithms/QuickLife.html#b0emulation
  #
  # Case 1: A totalistic rule containing B0 and S8 is converted into 
  # an equivalent rule (without B0) by inverting the neighbor counts, 
  # then using S(8-x) for the B counts and B(8-x) for the S counts. 
  # For example, B0123478/S01234678 (AntiLife) is changed to B3/S23 
  # (Life) via these steps: B0123478/S01234678 -> B56/S5 -> B3/S23.
  #
  # Case 2: A totalistic rule containing B0 but not S8 is converted 
  # into a pair of rules (both without B0): one is used for the even 
  # generations and the other for the odd generations. The rule for 
  # even generations uses inverted neighbor counts. The rule for odd 
  # generations uses S(8-x) for the B counts and B(8-x) for the S 
  # counts. For example, B03/S23 becomes B1245678/S0145678 (even) and 
  # B56/S58 (odd).
  #
  # make a list of pairs and triples of the following form:
  #   - case 1: <original rule, new rule>
  #   - case 2: <original rule, new rule part 1, new rule part2>
  #
  # for example:
  #   - case 1: <B0123478/S01234678, B3/S23>
  #   - case 2: <B03/S23, B1245678/S0145678, B56/S58>
  #
  # Parse the rule
  #
  # a set of the allowed numbers of neighbours
  neighbours = set("012345678")
  # split rule at "/"
  [born, survive] = rule.split("/")
  # drop "B" and "S" and make sets
  born = set(born[1:])
  survive = set(survive[1:])
  #
  # Problem: a rule with B0 in it might strobe. Rules without
  # B0 are not a problem. There are three cases to consider:
  #
  # Case 0: rule does not contain B0 --> do nothing
  #         -- all is good, no problem to fix
  #
  if not ("0" in born):
    return [rule]
  #
  # Case 1: rule contains B0 and S8 --> use reverse(rule)
  #         -- we know the rule contains B0, because we passed 
  #            over Case 0
  #         -- if the rule contains S8, then reverse(rule)
  #            cannot contain B0
  #
  if ("8" in survive):
    # reverse rule
    return [rule, reverse(rule)]
  #
  # Case 2: rule contains B0 and not S8 --> use unstrobe(rule)
  #         -- this splits the rule into two new rules
  #
  # - we know the rule contains B0, because passed over Case 0
  # - we know the rule does not contain S8, because we passed
  #   over Case 1
  # - we need to unstrobe the rule
  #
  # [rule, even_rule, odd_rule]
  return [rule] + unstrobe(rule) 
  #
#
# cosine(vec1, vec2) -- returns the cosine of the vectors
#
def cosine(vec1, vec2):
  """
  Calculate the cosine of vec1 and vec2.
  """
  assert len(vec1) == len(vec2)
  array1 = np.array(vec1, dtype=float)
  array2 = np.array(vec2, dtype=float)
  dot = np.dot(array1, array2)
  norm1 = np.linalg.norm(array1)
  norm2 = np.linalg.norm(array2)
  if ((norm1 > 0.0) and (norm2 > 0.0)):
    cos = dot / (norm1 * norm2)
  else:
    cos = 0.0
  return cos
#
# distance(vec1, vec2) -- returns euclidean distance between vectors
#
def distance(vec1, vec2):
  """
  Calculate euclidean distance between vec1 and vec2.
  """
  assert len(vec1) == len(vec2)
  array1 = np.array(vec1, dtype=float)
  array2 = np.array(vec2, dtype=float)
  difference = array1 - array2
  norm = np.linalg.norm(difference)
  return norm
#
# rule_to_boole(rule) -- returns a Boolean vector
#
def rule_to_boole(rule):
  """
  Convert a rule of the form 'B3/S23' into a Boolean vector.
  """
  # b = born, s = survive, u = unborn, d = die
  # intialize a semantic vector of zeroes of the form
  # <b0, b1, ..., b8, s0, s1, ..., s8, 
  #  u0, u1, ..., u8, d0, d1, ..., d8>
  #
  # initialize born and survive as <0> vectors
  born_vec = [0] * 9
  survive_vec = [0] * 9
  # initialize unborn and die as <1> vectors
  unborn_vec = [1] * 9
  die_vec = [1] * 9
  # read the rule to set the vector values
  type = ""
  for character in rule:
    # Born: 0 --> 1
    if (character == "B"):
      type = "B"
    # Survive: 1 --> 1
    elif (character == "S"):
      type = "S"
    # slash separator
    elif (character == "/"):
      continue
    # Born: 0 --> 1, Unborn: 0 --> 0
    # - born and unborn must necessarily be negations of each other
    elif (type == "B"):
      born_vec[int(character)] = 1
      unborn_vec[int(character)] = 0
    # Survive: 1 --> 1, Die: 1 --> 0
    # - survive and die must necessarily be negations of each other
    elif (type == "S"):
      survive_vec[int(character)] = 1
      die_vec[int(character)] = 0
  #
  # join the four parts
  #
  # let's have Born and Survive first (since B/S rules follow that convention)
  # followed by their complements in the same order:
  #
  #    born    = 0 --> 1
  #    survive = 1 --> 1
  #    unborn  = 0 --> 0   = complement of born    = not born
  #    die     = 1 --> 0   = complement of survive = not survive
  #
  vec = born_vec + survive_vec + unborn_vec + die_vec 
  # check
  assert len(vec) == sparams.single_vec_len
  # done
  return vec
#
# all_BS_rules() -- returns a list of all possible B/S rules (born/survive)
#
def all_BS_rules():
  """
  Make a list of all possible B/S rules (born/survive)
  - https://www.conwaylife.com/wiki/Rulestring#B.2FS_notation
  - there are 2^18 = 262,144 possible B/S rules
  - the Game of Life is "B3/S23" (born if 3 live neighbours / survive if 2 or 3)
  - the null rule "B/S" is legal, as is "B1/S" or "B/S1"
  - Golly supports all 262,144 of these rules
  """
  #
  num_rules = 2 ** 18
  rule_list = []
  #
  for rule_num in range(num_rules):
    # convert rule_num to a binary string with 18 characters
    # e.g. 14 --> '000000000000001110'
    binary_string = format(rule_num, '018b')
    # the binary string '111111111111111111' yields the rule
    # 'B012345678/S012345678' -- if there are any 0 values
    # in the binary string, then we delete the corresponding
    # number from the rule 'B012345678/S012345678'
    born = binary_string[0:9] # first 9 bits in binary_string
    survive = binary_string[9:18] # last 9 bits in binary_string
    # born
    rule = "B"
    for pos in range(9):
      if (born[pos] == '1'):
        rule = rule + str(pos)
    # survive
    rule = rule + "/S"
    for pos in range(9):
      if (survive[pos] == '1'):
        rule = rule + str(pos)
    # append the new rule to rule_list
    rule_list.append(rule)
  #
  return rule_list
#
# tsv_BS_rule_cpu(rule_file_name, current_cpu_id) 
# -- load B/S rules with associated CPUs
#
def tsv_BS_rule_cpu(rule_file_name, current_cpu_id):
  """
  Load a list of B/S rules from a file. We assume the file is a
  tab-separated value (tsv) file with the B/S rule in the first
  column and a CPU number in the second column: "B3/S368\tCPU5"
  """
  #
  rule_list = []
  #
  with open(rule_file_name) as tsvfile:
    reader = csv.reader(tsvfile, delimiter = '\t')
    for row in reader:
      rule = row[0]
      cpu = row[1]
      if (("CPU" + str(current_cpu_id)) == cpu):
        rule_list.append(rule) 
  #
  return rule_list
#
# show_parameters() -- returns a list of parameters and values
#
def show_parameters():
  """
  Make a list of the parameters in sparams and show
  the value of each parameter.
  """
  parameter_names = sorted(dir(sparams))
  display_list = []
  #
  for name in parameter_names:
    # skip over system names
    # - system names have the form "__file__"
    if (name[0] != "_"): 
      value = str(getattr(sparams, name))
      display_list.append(name + " = " + value)
  #
  return display_list
#
#
#
